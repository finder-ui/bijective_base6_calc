{
    "pageTitle": "Bijective Base-6 Calculator & Explorer",
    "pageDescription": "An interactive educational tool to calculate and explore the bijective base-6 number system, which has no zero. Features a live converter and reference tables.",
    "themeSwitcherLabel": "Toggle theme",
    "mainTitle": "Bijective Base-6 Calculator & Explorer",
    "tabCalculator": "Calculator & Explorer",
    "tabTables": "Reference Tables",
    "tabExplanations": "Explanations",
    "calculatorTitle": "Bijective Math Calculator",
    "calculatorDesc": "Enter two bijective base-6 numbers to see the results for all operations.",
    "num1Placeholder": "First number",
    "num2Placeholder": "Second number",
    "calculateBtn": "Calculate All Operations",
    "resultsTitle": "Results",
    "additionTableTitle": "Addition Table (1 to 12)",
    "multiplicationTableTitle": "Multiplication Table (1 to 12)",
    "primerTitle": "Why Use a Number System Without Zero?",
    "primerDesc1": "In our standard decimal system, zero is a placeholder. But this can cause problems: is <code>007</code> the same as <code>7</code>? In bijective numeration, these issues vanish. Every number has exactly one unique representation, making it perfect for IDs and codes.",
    "primerDesc2": "A fun side effect: with a base-6 bijective system, you can count higher than 10 on two hands. Each hand represents a digit (1-6). The number 11 (bijective) is 7 (decimal), represented by one finger on one hand and one on the other. You can count up to <strong>42</strong> (66 in bijective) this way!",
    "explanationTitle": "What is Bijective Base-6?",
    "explanationDesc1": "It's a positional system using digits <strong>1, 2, 3, 4, 5, 6</strong>. After <code>6</code>, the sequence continues to <code>11</code>, <code>12</code>, etc., just like spreadsheet columns (A-Z, then AA). This one-to-one mapping (a 'bijection') between numbers and their string representations is its key feature.",
    "algoTitle": "The Conversion Algorithm Explained",
    "algoDesc1": "The trick to converting from decimal is to temporarily shift the number system. Computers use remainders from 0-5, but our digits are 1-6. We bridge this gap by subtracting 1 before each calculation.",
    "algoExampleTitle": "Let's convert the decimal number <strong>43</strong>:",
    "algoStep1": "<strong>Step 1:</strong> <code>(43 - 1) % 6 = 0</code>. The 0th digit in <code>\\\"123456\\\"</code> is '1'. Result: <strong>1</strong>. Next number: <code>floor((43 - 1) / 6) = 7</code>.",
    "algoStep2": "<strong>Step 2:</strong> <code>(7 - 1) % 6 = 0</code>. The 0th digit is '1'. Result: <strong>11</strong>. Next number: <code>floor((7 - 1) / 6) = 1</code>.",
    "algoStep3": "<strong>Step 3:</strong> <code>(1 - 1) % 6 = 0</code>. The 0th digit is '1'. Result: <strong>111</strong>. Next number: <code>floor((1 - 1) / 6) = 0</code>.",
    "algoResult": "The process stops. The final result is <code>111</code>.",
    "applicationsTitle": "Key Benefits & Applications",
    "appUnambiguous": "<strong>Unambiguous & Human-Friendly:</strong> Perfect for product codes, serial numbers, or URL shorteners that can never be mistyped due to a missing or extra zero.",
    "appCompact": "<strong>Compact but Readable:</strong> More compact than binary but often easier for humans to parse at a glance than hexadecimal.",
    "appCrypto": "<strong>Natural Fit for Cryptography:</strong> Guarantees one-to-one mappings (canonical representation), which is critical for preventing subtle bugs and security vulnerabilities. In a theoretical computer built on this system, the classic 'null pointer exception' (an error from accessing address 0) wouldn't exist in the same way, as the first address is 1.",
    "donationBtn": "Support this Project",
    "githubLink": "Project source available on",
    "licenseLink": "Released under the"
}
