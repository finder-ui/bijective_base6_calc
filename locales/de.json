{
    "pageTitle": "Bijektiver Base-6 Rechner & Explorer",
    "pageDescription": "Ein interaktives Lehrmittel zum Berechnen und Erforschen des bijektiven Zahlensystems zur Basis 6, das keine Null hat. Mit Echtzeit-Konverter und Referenztabellen.",
    "mainTitle": "Bijektiver Base-6 Rechner & Explorer",
    "tabCalculator": "Rechner",
    "tabTables": "Referenztabellen",
    "tabProsCons": "Vor- & Nachteile",
    "tabLearn": "Lernen",
    "tabPractice": "√úben",
    "calculatorTitle": "Bijektiver Mathe-Rechner",
    "calculatorDesc": "Geben Sie zwei bijektive Basis-6-Zahlen ein, um die Ergebnisse f√ºr alle Standard-Rechenoperationen zu sehen.",
    "num1Placeholder": "Erste Zahl",
    "num2Placeholder": "Zweite Zahl",
    "calculateBtn": "Berechnen",
    "resultsTitle": "Ergebnisse",
    "liveConverterTitle": "Live-Zahlensystem-Explorer",
    "liveConverterDesc": "Geben Sie eine Standard-Dezimalzahl ein, um ihre Echtzeit-Darstellung in verschiedenen Systemen zu sehen.",
    "decimalInputLabel": "Geben Sie eine Dezimalzahl ein:",
    "decimalInputPlaceholder": "z.B. 43",
    "additionTableTitle": "Additionstabelle (1 bis 24)",
    "multiplicationTableTitle": "Multiplikationstabelle (1 bis 24)",
    "explanationTitle": "Das bijektive System verstehen",
    "explanationDesc1": "Dieses System ist eine <strong>bijektive Zahldarstellung zur Basis 6</strong>. Es ist positionell, aber mit zwei wesentlichen Unterschieden: Es hat keine Null, und seine Ziffern reichen von 1 bis 6. Da es keine Null als Platzhalter gibt, 'rollt' das System anders √ºber. Nach <code>6</code> ist die n√§chste Zahl <code>11</code>.",
    "algoTitle": "Der Konvertierungsalgorithmus erkl√§rt",
    "algoDesc1": "Der Trick bei der Umwandlung von Dezimal in bijektive Basis 6 besteht darin, das Zahlensystem vor√ºbergehend zu verschieben. Computer arbeiten nat√ºrlich mit Resten von 0 bis 5, aber unsere Ziffern sind 1 bis 6. Wir √ºberbr√ºcken diese L√ºcke, indem wir vor jeder Berechnung 1 subtrahieren.",
    "visualizerTitle": "Algorithmus-Visualisierer",
    "visualizerDesc": "Geben Sie eine Dezimalzahl ein, um den Konvertierungsalgorithmus in Aktion zu sehen.",
    "visualizerInputPlaceholder": "Dezimalzahl zur Visualisierung eingeben...",
    "visualizeBtn": "Visualisieren",
    "formalLangTitle": "Die Mathematik hinter der Magie: Eine Verbindung zur Theorie der formalen Sprachen",
    "formalLangDesc1": "Das bijektive Base-6-System hat eine tiefe und sch√∂ne Verbindung zur Theorie der formalen Sprachen, einem Eckpfeiler der theoretischen Informatik.",
    "formalLangDesc2": "In diesem Bereich definieren wir ein Alphabet, Sigma, als eine Menge von Symbolen. F√ºr unser System ist das Alphabet Sigma = {1, 2, 3, 4, 5, 6}.",
    "formalLangDesc3": "Die Menge aller m√∂glichen Zeichenketten, die mit diesem Alphabet erstellt werden k√∂nnen, ist als Kleene-Stern (oder Kleene-H√ºlle) von Sigma bekannt, bezeichnet als Sigma*. Diese Menge umfasst Zeichenketten beliebiger endlicher L√§nge: {leere Zeichenkette, 1, 2, ..., 6, 11, 12, ..., 66, 111, ...}.",
    "formalLangDesc4": "Das bijektive Base-6-System ist im Wesentlichen eine perfekte, geordnete Aufz√§hlung des Kleene-Sterns des Alphabets {1, 2, 3, 4, 5, 6}, wenn wir die leere Zeichenkette der Null zuordnen. Jede positive ganze Zahl entspricht genau einer Zeichenkette, und jede Zeichenkette entspricht genau einer positiven ganzen Zahl. Dies ist unglaublich m√§chtig, da es eine nahtlose M√∂glichkeit bietet, jeder Sequenz von Ereignissen oder Entscheidungen aus einer Menge von sechs eine eindeutige Nummer zuzuweisen, eine grundlegende Operation in Algorithmen und der Berechenbarkeitstheorie.",
    "geomTitle": "Eine geometrische Interpretation: Der unendliche 6-stellige Baum",
    "geomDesc1": "Wir k√∂nnen das gesamte System als einen unendlichen, vollst√§ndigen 6-stelligen Baum visualisieren. Ein 6-stelliger Baum ist eine Struktur, bei der jeder Knoten genau sechs Kinder hat.",
    "geomDesc2": "Die Wurzel des Baumes kann als Ausgangspunkt betrachtet werden (der die Zahl 0 oder die leere Zeichenkette darstellt).",
    "geomList": [ "Die erste Ebene der Knoten ist mit 1, 2, 3, 4, 5 und 6 beschriftet.", "Jeder dieser Knoten hat sechs Kinder. Zum Beispiel ist der Knoten ‚Äû1‚Äú der √ºbergeordnete Knoten der Knoten ‚Äû11‚Äú, ‚Äû12‚Äú, ‚Äû13‚Äú, ‚Äû14‚Äú, ‚Äû15‚Äú und ‚Äû16‚Äú." ],
    "geomDesc4": "In diesem Modell ist jede bijektive Base-6-Zahl die eindeutige ‚ÄûAdresse‚Äú oder der ‚ÄûPfad‚Äú von der Wurzel zu einem bestimmten Knoten. Zum Beispiel bedeutet die Zahl 425:",
    "geomPathList": [ "Beginnen Sie an der Wurzel.", "Nehmen Sie den 4. Zweig.", "Nehmen Sie von diesem Knoten den 2. Zweig.", "Nehmen Sie von diesem Knoten den 5. Zweig." ],
    "hashingTitle": "Ein Hinweis zu Kollisionen und Hashing",
    "hashingDesc": "Bei der Betrachtung der Multiplikationstabelle stellt man fest, dass <code>2 √ó 3 = 6</code> und <code>1 √ó 6 = 6</code> ist. Dies ist eine <strong>Kollision</strong>. Obwohl mathematisch interessant, ist diese Eigenschaft das Gegenteil von dem, was in kryptographischen Hash-Funktionen (wie SHA-256) erw√ºnscht ist, die speziell darauf ausgelegt sein m√ºssen, das Finden von Kollisionen rechnerisch unm√∂glich zu machen. Dieses System ist daher ein gutes Werkzeug, um das Konzept der Kollisionen zu verstehen, aber es ist selbst kein sicherer Hashing-Algorithmus.",
    "prosTitle": "Vorteile der bijektiven Basis 6",
    "prosIntro": "Die nulllose Natur dieses Systems bietet mehrere einzigartige Vorteile, insbesondere in der Datenverarbeitung und bei f√ºr Menschen lesbaren Bezeichnern.",
    "pros": [
        { "title": "Eindeutig & menschenfreundlich", "desc": "Keine f√ºhrenden Nullen bedeuten keine Verwirrung. <code>123</code> ist immer <code>123</code>, niemals <code>0123</code>. Dies ist ideal f√ºr Produktcodes, Seriennummern oder kurze Links, bei denen Klarheit entscheidend ist." },
        { "title": "Kompakt & Effizient", "desc": "Jede m√∂gliche Zeichenfolge von Ziffern ist eine g√ºltige Zahl, was es zu einer sehr dichten und effizienten Art der Datendarstellung macht. Es gibt keine verschwendeten oder ung√ºltigen Kombinationen." },
        { "title": "Nat√ºrliche Eignung f√ºr die Datenverarbeitung", "desc": "Die Eins-zu-eins-Zuordnung ist ideal f√ºr Algorithmen, die eindeutige Bezeichner ben√∂tigen, wie z.B. die Indizierung komplexer Datenstrukturen oder die Erzeugung von Schl√ºsseln in verteilten Systemen." },
        { "title": "Eliminierung von Null-Referenzen (Eine theoretische Idee)", "desc": "Sie haben gefragt, ob ein auf diesem System aufgebauter Computer Nullzeiger h√§tte. Im theoretischen Sinne sind Sie auf etwas Tiefgr√ºndiges gesto√üen! Da es keine ‚ÄûNull‚Äú gibt, um ‚Äûnichts‚Äú oder einen nicht initialisierten Zustand darzustellen, bezieht sich jede m√∂gliche Ziffernfolge auf eine g√ºltige, eindeutige Zahl. Dies passt wunderbar zur Idee der Eliminierung von Null-Referenzen, einer h√§ufigen Fehlerquelle in der Programmierung." },
        { "title": "H√∂heres Z√§hlen mit den Fingern", "desc": "Mit zehn Fingern kann man weit √ºber 10 hinaus z√§hlen. Jede Hand kann eine bijektive Ziffer zur Basis 6 darstellen (1-5 Finger oder eine geschlossene Faust f√ºr 6). Mit zwei H√§nden k√∂nnen Sie jede Zahl von 1 bis 42 darstellen, wobei ein Finger an der linken und ein Finger an der rechten Hand 7 (bijektiv 11) bedeutet." }
    ],
    "consTitle": "Nachteile und Kompromisse",
    "consIntro": "Obwohl leistungsstark, wird das System aus einigen wichtigen Gr√ºnden nicht f√ºr die allgemeine Arithmetik verwendet.",
    "cons": [
        { "title": "Ungewohnte Arithmetik", "desc": "Die Regeln f√ºr den √úbertrag beim Addieren und Subtrahieren unterscheiden sich vom Dezimalsystem, was Kopfrechnen und manuelle Berechnungen f√ºr die meisten Menschen zu einer Herausforderung macht." },
        { "title": "Konvertierungsaufwand", "desc": "Es ist kein natives System f√ºr Computer (die bin√§r verwenden) oder Menschen (die dezimal verwenden). Ein Konvertierungsschritt ist immer erforderlich, wenn mit anderen Systemen interagiert wird, was zus√§tzlichen Rechenaufwand bedeutet." },
        { "title": "Begrenzte native Unterst√ºtzung", "desc": "Sehr wenige Programmiersprachen oder Standardbibliotheken haben eingebaute Funktionen f√ºr die bijektive Z√§hlung. Das bedeutet, dass Entwickler benutzerdefinierte Logik f√ºr alle arithmetischen und Konvertierungsoperationen implementieren m√ºssen." },
        { "title": "Komplexe Multiplikationsmuster", "desc": "Im Gegensatz zu Standardbasen, bei denen die Multiplikation mit der Basis einfach eine Null hinzuf√ºgt, sind die Muster bei der bijektiven Multiplikation weniger intuitiv, was schnelle Sch√§tzungen oder Berechnungen erschwert." }
    ],
    "practiceTitle": "√úbungsmodus",
    "practiceDesc": "Testen Sie Ihre F√§higkeiten gegen die Uhr! W√§hlen Sie einen Schwierigkeitsgrad und l√∂sen Sie die Aufgaben.",
    "difficultyLabel": "Schwierigkeit:",
    "difficultyEasy": "Leicht",
    "difficultyMedium": "Mittel",
    "difficultyHard": "Schwer",
    "quizQuestion": "Was ist",
    "quizTypeConversion": "Umwandlung",
    "quizTypeMath": "Mathe",
    "quizQuestionConversionSuffix": "in bijektiver Base-6?",
    "quizAnswerPlaceholder": "Ihre Antwort...",
    "quizSubmitBtn": "Senden",
    "quizCorrectFeedback": "Richtig! üéâ",
    "quizIncorrectFeedback": "Nicht ganz! Die richtige Antwort war",
    "quizNextBtn": "N√§chste Frage",
    "timeLabel": "Zeit:",
    "githubLink": "Projekt-Quellcode verf√ºgbar auf",
    "licenseLink": "Ver√∂ffentlicht unter der",
    "ui_loading": "Wird geladen...",
    "errorBothNumbers": "Bitte geben Sie beide Nummern ein.",
    "errorGeneric": "Fehler:"
}
